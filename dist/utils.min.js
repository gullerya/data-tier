import{Observable}from"./object-observer.min.js";const SCOPE_ROOT_KEY=Symbol("scope.root"),VIEW_PARAMS_KEY=Symbol("view.params"),DEFAULT_TIE_TARGET_PROVIDER="defaultTieTarget",CHANGE_EVENT_NAME_PROVIDER="changeEventName",PARAM_SPLITTER=/\s*=>\s*/,MULTI_PARAMS_SPLITTER=/\s*[,;]\s*/,DEFAULT_VALUE_ELEMENTS={INPUT:1,SELECT:1,TEXTAREA:1},DEFAULT_SRC_ELEMENTS={IMG:1,IFRAME:1,SOURCE:1},DEFAULT_HREF_ELEMENTS={A:1,ANIMATE:1,AREA:1,BASE:1,DISCARD:1,IMAGE:1,LINK:1,PATTERN:1,use:1},DEFAULT_CHANGE_ELEMENTS={INPUT:1,SELECT:1,TEXTAREA:1},randomKeySource="abcdefghijklmnopqrstuvwxyz0123456789",randomKeySourceLen=randomKeySource.length;export{SCOPE_ROOT_KEY,VIEW_PARAMS_KEY,DEFAULT_TIE_TARGET_PROVIDER,ensureObservable,getTargetProperty,extractViewParams,CHANGE_EVENT_NAME_PROVIDER,addChangeListener,delChangeListener,getPath,setPath,setViewProperty,callViewFunction,getRandomKey};class Parameter{constructor(e,t,r,n,o,a){this.tieKey=e,this.rawPath=t,this.path=r,this.targetProperty=n,this.isFunctional=o,this.fParams=a,this.iClasses=null}}function ensureObservable(e){return e?Observable.isObservable(e)?e:Observable.from(e):Observable.from({})}function getTargetProperty(e){let t=e[DEFAULT_TIE_TARGET_PROVIDER];if(!t){const r=e.nodeName;t="INPUT"===r&&"checkbox"===e.type?"checked":r in DEFAULT_VALUE_ELEMENTS?"value":r in DEFAULT_SRC_ELEMENTS?"src":r in DEFAULT_HREF_ELEMENTS?"href":"textContent"}return t}function extractViewParams(e){const t=e.getAttribute("data-tie");return t?parseViewParams(t,e):null}function parseViewParams(e,t){const r=[],n={},o=e.split(MULTI_PARAMS_SPLITTER),a=o.length;let s,i,l,E=0;for(;E<a;E++)if((s=o[E])&&(i&&(i+=","+s),!(s.indexOf("(")>0&&(i=s).indexOf(")")<0)))try{i?(l=parseFunctionParam(i),i=null):l=parsePropertyParam(s,t),l.targetProperty in n?console.error(`elements's property '${l.targetProperty}' tied more than once; all but first dismissed`):(r.push(l),n[l.targetProperty]=!0)}catch(e){console.error(`failed to parse one of a multi param parts (${s}), skipping it`,e)}return r}function parseFunctionParam(e){const t=e.split(/[()]/),r=t[1].split(/\s*,\s*/).map(e=>{const t=e.split(":");if(!t.length||t.length>2||!t[0])throw new Error("invalid function tied value: "+e);const r=t.length>1?t[1]:"";return{tieKey:t[0],rawPath:r,path:r.split(".").filter(e=>e)}});if(!r.length)throw new Error(`functional tie parameter MUST have at least one tied argument, '${e}' doesn't`);return new Parameter(null,null,null,t[0],!0,r)}function parsePropertyParam(e,t){const r=e.split(PARAM_SPLITTER);1===r.length&&r.push(getTargetProperty(t));const n=r[0].split(":");if(!n.length||n.length>2||!n[0])throw new Error(`invalid tie parameter '${e}'; expected (example): "orders:0.address.street, orders:0.address.apt => title"`);let o=n[0];"scope"===n[0]&&(o=getScopedTieKey(t));const a=n.length>1?n[1]:"",s=new Parameter(o,a,a.split(".").filter(e=>e),r[1],!1,null);return"classList"===s.targetProperty&&(s.iClasses=Array.from(t.classList)),s}function getScopedTieKey(e){let t=e,r=t[SCOPE_ROOT_KEY];for(;!r&&t.parentNode;)(t=t.parentNode).host&&(t=t.host),r=t[SCOPE_ROOT_KEY];return r||null}function addChangeListener(e,t){const r=obtainChangeEventName(e);r&&e.addEventListener(r,t)}function delChangeListener(e,t){const r=obtainChangeEventName(e);r&&e.removeEventListener(r,t)}function obtainChangeEventName(e){let t=e[CHANGE_EVENT_NAME_PROVIDER];return t||e.nodeName in DEFAULT_CHANGE_ELEMENTS&&(t="change"),t}function getPath(e,t){if(!e)return null;const r=t,n=r.length;if(!n)return e;let o,a=e,s=0;for(;s<n-1;s++)if(null===(a=a[o=r[s]])||void 0===a)return a;return a[r[s]]}function setPath(e,t,r){if(!e)return;const n=t.length;let o,a,s=0;for(;s<n-1;s++)if((a=e[o=t[s]])&&"object"==typeof a)e=a;else if(void 0===a||null===a)e[o]={},e=e[o];else if("object"!=typeof a)return void console.error("setting deep path MAY NOT override primitives along the way");e[t[s]]=r}function setViewProperty(e,t,r){const n=t.targetProperty;try{if("href"===n&&"object"==typeof e.href)e.href.baseVal=r;else if("classList"===n){const n=t.iClasses.slice(0);r&&(Array.isArray(r)&&r.length?r.forEach(e=>{n.indexOf(e)<0&&n.push(e)}):"object"==typeof r?Object.keys(r).forEach(e=>{const t=n.indexOf(e);r[e]?t<0&&n.push(e):t>=0&&n.splice(t,1)}):"string"==typeof r&&n.indexOf(r)<0&&n.push(r)),e.className=n.join(" ")}else e[n]=r}catch(t){console.error(`failed to set '${n}' of '${e}' to '${r}'`,t)}}function callViewFunction(e,t,r){try{e[t].apply(e,r)}catch(n){console.error(`failed to call '${t}' of '${e}' with '${r}'`,n)}}function getRandomKey(e){let t="",r=e;const n=crypto.getRandomValues(new Uint8Array(e));for(;r;)r--,t+=randomKeySource.charAt(randomKeySourceLen*n[r]/256);return t}