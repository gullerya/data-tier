import{ensureObservable,getPath,setViewProperty,callViewFunction}from"./utils.min.js";const namedTies={},tieNameValidator=/^[a-zA-Z0-9]+$/;let VIEW_PARAMS_KEY,ties,views;class Tie{constructor(e,t){this.key=e,this.model=ensureObservable(t),this.views=null,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.key,i=this.model,s=this.views||(this.views=views[t]),o=Object.keys(s),r={};let n,a,l,d,h,f,c,w,m,v="";if(o.length)for(n=0,a=e.length;n<a;n++){if(d=(l=e[n]).object,h=l.path,!Array.isArray(d)||"insert"!==l.type&&"delete"!==l.type||isNaN(h[h.length-1])){const e=h.length;if(e>1){for(let t=0;t<e-1;t++)v+=h[t]+".";v+=h[e-1]}else 1===e&&(v=h[0])}else{if(r[v=h.slice(0,-1).join(".")]===d)continue;r[v]=d,l=null}for(f=o.length;f;)if(0===(c=o[--f]).indexOf(v)||0===v.indexOf(c))for(m=(w=s[c]).length;m;)this.updateView(w[--m],v,l,t,i)}}updateView(e,t,i,s,o){const r=e[VIEW_PARAMS_KEY];let n=r.length;for(;n;){const a=r[--n];if(a.isFunctional){if(a.fParams.some(e=>e.tieKey===s&&0===e.rawPath.indexOf(t))){let t=!1;const s=[];a.fParams.forEach(e=>{let i;const o=ties.get(e.tieKey);o&&(i=getPath(o,e.path),t=!0),s.push(i)}),t&&(s.push([i]),callViewFunction(e,a.targetProperty,s))}}else{if(a.tieKey!==s)continue;if(0!==a.rawPath.indexOf(t)&&0!==t.indexOf(a.rawPath))continue;let r;i&&void 0!==i.value&&t===a.rawPath?i&&(r=i.value):r=getPath(o,a.path),void 0===r&&(r=""),setViewProperty(e,a,r)}}}}export class Ties{constructor(e,t){VIEW_PARAMS_KEY=e,ties=this,views=t}get(e){const t=namedTies[e];return t?t.model:void 0}create(e,t){if(namedTies[e])throw new Error(`tie '${e}' already exists`);if(this.validateTieKey(e),null===t)throw new Error("initial model, when provided, MUST NOT be null");e in views||(views[e]={});const i=new Tie(e,t);return namedTies[e]=i,namedTies[e].processDataChanges([{path:[]}]),i.model}remove(e){let t;if("object"==typeof e)t=Object.keys(namedTies).find(t=>namedTies[t].model===e);else{if("string"!=typeof e)throw new Error("tie to remove MUST either be a valid tie key or tie self");t=e}delete views[t];const i=namedTies[t];i&&(i.model&&i.ownModel&&i.model.revoke(),delete namedTies[t])}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};