import{SCOPE_ROOT_KEY,VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction,getRandomKey}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["scope"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.views,i=t._pathsCache,o=i.length;let s,r,n,a,l,h,d,f,w,c,m,p,y,E,T,g,v,u="";if(o)for(s=0,r=e.length;s<r;s++)if(h=(l=(n=e[s]).path).length,!l.some(e=>"symbol"==typeof e)){for(E=!1,a=n.object,!Array.isArray(a)||"insert"!==n.type&&"delete"!==n.type||isNaN(l[l.length-1])?1===h?u=l[0]:h&&(u=2===h?l[0]+"."+l[1]:l.join(".")):(u=l.slice(0,-1).join("."),E=!0),m=u.length,d=o,v=new Map;d;)if(m>(f=i[--d]).length?(p=f,y=u):(p=u,y=f),T=p===y&&!E,0===y.indexOf(p))for(c=(w=t[f]).length;c;){g=w[--c];let e=v.get(g);e||(e={},v.set(g,e)),e[f]=T}this.updateViews(v,n)}}updateViews(e,t){let i,o;e.forEach((e,s)=>{for(i=s[VIEW_PARAMS_KEY],o=i.length;o;){const r=i[--o];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let o;const s=ties.get(t.tieKey);s&&(o=getPath(s,t.path),e=!0),i.push(o)}),e&&(i.push([t]),callViewFunction(s,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),setViewProperty(s,r,i)}}})}}export class Ties{constructor(){ties=this}get(e){const t="string"==typeof e?e:e?e[SCOPE_ROOT_KEY]:void 0,i=ties[t];return i?i.model:null}create(e,t){if(ties[e])throw new Error(`tie '${e}' already exists`);this.validateTieKey(e);let i=e;if("string"!=typeof i&&(i=getRandomKey(16),e[SCOPE_ROOT_KEY]=i),null===t)throw new Error("initial model, when provided, MUST NOT be null");const o=obtainTieViews(i),s=new Tie(i,t,o);return ties[i]=s,s.processDataChanges([{path:[]}]),s.model}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e[SCOPE_ROOT_KEY]:Object.keys(ties).find(t=>ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);const i=ties[t];i&&(delete ties[t],deleteTieViews(t),i.model&&i.ownModel&&i.model.revoke())}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};