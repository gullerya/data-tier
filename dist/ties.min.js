import{VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const namedTies={},rootedTies=new WeakMap,tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["root"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.views,i=Object.keys(t),o=i.length;let s,r,a,n,l,d,h,f,m,w,T,c,y,p,g,v,E="";if(o)for(s=0,r=e.length;s<r;s++){if(y=!1,n=(a=e[s]).object,l=a.path,!Array.isArray(n)||"insert"!==a.type&&"delete"!==a.type||isNaN(l[l.length-1])){const e=l.length;1===e?E=l[0]:e&&(E=2===e?l[0]+"."+l[1]:l.join("."))}else E=l.slice(0,-1).join("."),y=!0;for(w=E.length,d=o,v=new Map;d;)if(w>(h=i[--d]).length?(T=h,c=E):(T=E,c=h),p=T===c&&!y,0===c.indexOf(T))for(m=(f=t[h]).length;m;){g=f[--m];let e=v.get(g);e||(e={},v.set(g,e)),e[h]=p}this.updateViews(v,a)}}updateViews(e,t){let i,o;e.forEach((e,s)=>{for(i=s[VIEW_PARAMS_KEY],o=i.length;o;){const r=i[--o];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let o;const s=ties.get(t.tieKey);s&&(o=getPath(s,t.path),e=!0),i.push(o)}),e&&(i.push([t]),callViewFunction(s,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),setViewProperty(s,r,i)}}})}}export class Ties{constructor(){ties=this}get(e){let t;return(t="string"==typeof e?namedTies[e]:rootedTies.get(e))?t.model:void 0}create(e,t){if(namedTies[e])throw new Error(`tie '${e}' already exists`);if(this.validateTieKey(e),null===t)throw new Error("initial model, when provided, MUST NOT be null");const i=obtainTieViews(e),o=new Tie(e,t,i);return"string"==typeof e?namedTies[e]=o:rootedTies.set(e,o),o.processDataChanges([{path:[]}]),o.model}remove(e){let t,i;if("object"==typeof e&&e.nodeType===Node.ELEMENT_NODE)i=e,t=rootedTies.get(i),rootedTies.delete(i);else{if("string"!=typeof e&&"object"!=typeof e)throw new Error("tie to remove MUST either be a valid tie key or tie self");i="object"==typeof e?Object.keys(namedTies).find(t=>namedTies[t].model===e):e,t=namedTies[i],delete namedTies[i]}deleteTieViews(i),t&&t.model&&t.ownModel&&t.model.revoke()}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};