import{ensureObservable,getPath,setViewProperty,callViewFunction}from"./utils.min.js";const namedTies={},rootedTies=new WeakMap,tieNameValidator=/^[a-zA-Z0-9]+$/;let VIEW_PARAMS_KEY,ties,views,rootedViews;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.key,i=this.views,s=Object.keys(i),o={};let r,n,a,l,d,h,w,f,c,m="";if(s.length)for(r=0,n=e.length;r<n;r++){if(l=(a=e[r]).object,d=a.path,!Array.isArray(l)||"insert"!==a.type&&"delete"!==a.type||isNaN(d[d.length-1])){const e=d.length;if(e>1){for(let t=0;t<e-1;t++)m+=d[t]+".";m+=d[e-1]}else 1===e&&(m=d[0])}else{if(o[m=d.slice(0,-1).join(".")]===l)continue;o[m]=l,a=null}for(h=s.length;h;)if(0===(w=s[--h]).indexOf(m)||0===m.indexOf(w))for(c=(f=i[w]).length;c;)this.updateView(f[--c],m,a,t)}}updateView(e,t,i,s){const o=e[VIEW_PARAMS_KEY];let r=o.length;for(;r;){const n=o[--r];if(n.isFunctional){if(n.fParams.some(e=>e.tieKey===s&&0===e.rawPath.indexOf(t))){let t=!1;const s=[];n.fParams.forEach(e=>{let i;const o=ties.get(e.tieKey);o&&(i=getPath(o,e.path),t=!0),s.push(i)}),t&&(s.push([i]),callViewFunction(e,n.targetProperty,s))}}else{if(n.tieKey!==s)continue;if(0!==n.rawPath.indexOf(t)&&0!==t.indexOf(n.rawPath))continue;let o;i&&void 0!==i.value&&t===n.rawPath?i&&(o=i.value):o=getPath(this.model,n.path),void 0===o&&(o=""),setViewProperty(e,n,o)}}}}export class Ties{constructor(e,t,i){VIEW_PARAMS_KEY=e,ties=this,views=t,rootedViews=i}get(e){let t;return(t="string"==typeof e?namedTies[e]:rootedTies.get(e))?t.model:void 0}create(e,t){if(namedTies[e])throw new Error(`tie '${e}' already exists`);if(this.validateTieKey(e),null===t)throw new Error("initial model, when provided, MUST NOT be null");let i;return"string"==typeof e?(e in views||(views[e]={}),i=new Tie(e,t,views[e]),namedTies[e]=i):(rootedViews.has(e)||rootedViews.set(e,{}),i=new Tie(e,t,rootedViews.get(e)),rootedTies.set(e,i)),i.processDataChanges([{path:[]}]),i.model}remove(e){let t;if("object"==typeof e)t=Object.keys(namedTies).find(t=>namedTies[t].model===e);else{if("string"!=typeof e)throw new Error("tie to remove MUST either be a valid tie key or tie self");t=e}delete views[t];const i=namedTies[t];i&&(i.model&&i.ownModel&&i.model.revoke(),delete namedTies[t])}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};