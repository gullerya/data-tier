import{VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const namedTies={},rootedTies=new WeakMap,tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["root"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.key,i=this.views,o=Object.keys(i),s={};let r,n,a,l,d,h,f,m,w,T="";if(o.length)for(r=0,n=e.length;r<n;r++){if(l=(a=e[r]).object,d=a.path,!Array.isArray(l)||"insert"!==a.type&&"delete"!==a.type||isNaN(d[d.length-1])){const e=d.length;if(e>1){for(let t=0;t<e-1;t++)T+=d[t]+".";T+=d[e-1]}else 1===e&&(T=d[0])}else{if(s[T=d.slice(0,-1).join(".")]===l)continue;s[T]=l,a=null}for(h=o.length;h;)if(0===(f=o[--h]).indexOf(T)||0===T.indexOf(f))for(w=(m=i[f]).length;w;)this.updateView(m[--w],T,a,t)}}updateView(e,t,i,o){const s=e[VIEW_PARAMS_KEY];let r=s.length;for(;r;){const n=s[--r];if(n.isFunctional){if(n.fParams.some(e=>e.tieKey===o&&0===e.rawPath.indexOf(t))){let t=!1;const o=[];n.fParams.forEach(e=>{let i;const s=ties.get(e.tieKey);s&&(i=getPath(s,e.path),t=!0),o.push(i)}),t&&(o.push([i]),callViewFunction(e,n.targetProperty,o))}}else{if(n.tieKey!==o)continue;if(0!==n.rawPath.indexOf(t)&&0!==t.indexOf(n.rawPath))continue;let s;i&&void 0!==i.value&&t===n.rawPath?i&&(s=i.value):s=getPath(this.model,n.path),void 0===s&&(s=""),setViewProperty(e,n,s)}}}}export class Ties{constructor(){ties=this}get(e){let t;return(t="string"==typeof e?namedTies[e]:rootedTies.get(e))?t.model:void 0}create(e,t){if(namedTies[e])throw new Error(`tie '${e}' already exists`);if(this.validateTieKey(e),null===t)throw new Error("initial model, when provided, MUST NOT be null");const i=obtainTieViews(e),o=new Tie(e,t,i);return"string"==typeof e?namedTies[e]=o:rootedTies.set(e,o),o.processDataChanges([{path:[]}]),o.model}remove(e){let t,i;if("object"==typeof e&&e.nodeType===Node.ELEMENT_NODE)i=e,t=rootedTies.get(i),rootedTies.delete(i);else{if("string"!=typeof e&&"object"!=typeof e)throw new Error("tie to remove MUST either be a valid tie key or tie self");i="object"==typeof e?Object.keys(namedTies).find(t=>namedTies[t].model===e):e,t=namedTies[i],delete namedTies[i]}deleteTieViews(i),t&&t.model&&t.ownModel&&t.model.revoke()}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};