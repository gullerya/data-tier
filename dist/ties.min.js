import{VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const namedTies={},rootedTies=new WeakMap,tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["root"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.views,i=Object.keys(t),o=i.length,s={};let r,n,a,l,d,h,f,m,w,T,c,y,p,g,v,u="";if(o)for(r=0,n=e.length;r<n;r++){if(l=(a=e[r]).object,d=a.path,!Array.isArray(l)||"insert"!==a.type&&"delete"!==a.type||isNaN(d[d.length-1])){const e=d.length;1===e?u=d[0]:e&&(u=2===e?d[0]+"."+d[1]:d.join("."))}else{if(s[u=d.slice(0,-1).join(".")]===l)continue;s[u]=l,a=null}for(T=u.length,h=o,v=new Map;h;)if(T>(f=i[--h]).length?(c=f,y=u):(c=u,y=f),p=c===y,0===y.indexOf(c))for(w=(m=t[f]).length;w;){g=m[--w];let e=v.get(g);e||(e={},v.set(g,e)),e[f]=p}this.updateViews(v,a)}}updateViews(e,t){let i,o;e.forEach((e,s)=>{for(i=s[VIEW_PARAMS_KEY],o=i.length;o;){const r=i[--o];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let o;const s=ties.get(t.tieKey);s&&(o=getPath(s,t.path),e=!0),i.push(o)}),e&&(i.push([t]),callViewFunction(s,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),setViewProperty(s,r,i)}}})}}export class Ties{constructor(){ties=this}get(e){let t;return(t="string"==typeof e?namedTies[e]:rootedTies.get(e))?t.model:void 0}create(e,t){if(namedTies[e])throw new Error(`tie '${e}' already exists`);if(this.validateTieKey(e),null===t)throw new Error("initial model, when provided, MUST NOT be null");const i=obtainTieViews(e),o=new Tie(e,t,i);return"string"==typeof e?namedTies[e]=o:rootedTies.set(e,o),o.processDataChanges([{path:[]}]),o.model}remove(e){let t,i;if("object"==typeof e&&e.nodeType===Node.ELEMENT_NODE)i=e,t=rootedTies.get(i),rootedTies.delete(i);else{if("string"!=typeof e&&"object"!=typeof e)throw new Error("tie to remove MUST either be a valid tie key or tie self");i="object"==typeof e?Object.keys(namedTies).find(t=>namedTies[t].model===e):e,t=namedTies[i],delete namedTies[i]}deleteTieViews(i),t&&t.model&&t.ownModel&&t.model.revoke()}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};