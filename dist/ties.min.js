import{ensureObservable,getPath,callViewFunction,getRandomKey}from"./utils.min.js";const tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["scope"];class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.ties=i,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.ties.dti.views.obtainTieViews(this.key),i=t._pathsCache,s=i.length;let o,r,a,n,h,l,d,c,p,y,f,w,m,g,v,u,T,E="";if(s)for(o=0,r=e.length;o<r;o++)if(l=(h=(a=e[o]).path).length,!h.some(e=>"symbol"==typeof e)){for(g=!1,n=a.object,!Array.isArray(n)||"insert"!==a.type&&"delete"!==a.type||isNaN(h[h.length-1])?1===l?E=h[0]:l&&(E=2===l?h[0]+"."+h[1]:h.join(".")):(E=h.slice(0,-1).join("."),g=!0),f=E.length,d=s,T=new Map;d;)if(f>(c=i[--d]).length?(w=c,m=E):(w=E,m=c),v=w===m&&!g,0===m.indexOf(w))for(y=(p=t[c]).length;y;){u=p[--y];let e=T.get(u);e||(e={},T.set(u,e)),e[c]=v}this.updateViews(T,a)}}updateViews(e,t){let i,s;e.forEach((e,o)=>{for(i=o[this.ties.dti.paramsKey],s=i.length;s;){const r=i[--s];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let s;const o=this.ties.get(t.tieKey);o&&(s=getPath(o,t.path),e=!0),i.push(s)}),e&&(i.push([t]),callViewFunction(o,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),this.ties.dti.views.setViewProperty(o,r,i)}}})}}export class Ties{constructor(e){this.dti=e,this.ties={}}get(e){const t="string"==typeof e?e:e?e[this.dti.scopeRootKey]:void 0,i=this.ties[t];return i?i.model:null}create(e,t){if(this.ties[e])throw new Error(`tie '${e}' already exists`);if(null===t)throw new Error("initial model, when provided, MUST NOT be null");this.validateTieKey(e);let i=e;"string"!=typeof i&&((i=e[this.dti.scopeRootKey])||(i=getRandomKey(16),e[this.dti.scopeRootKey]=i));const s=this.dti.views.obtainTieViews(i),o=new Tie(i,t,this,s);return this.ties[i]=o,o.processDataChanges([{path:[]}]),o.model}update(e,t){if(t&&"object"==typeof t){const i="string"==typeof e?e:e?e[this.dti.scopeRootKey]:void 0,s=this.ties[i];return s?(s.model!==t&&(s.model=t,s.processDataChanges([{path:[]}])),s.model):this.create(i,t)}}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e[this.dti.scopeRootKey]:Object.keys(this.ties).find(t=>this.ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);this.ties[t]&&(delete this.ties[t],this.dti.views.deleteTieViews(t))}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};