import{SCOPE_ROOT_KEY,VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction,getRandomKey}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["scope"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.views,i=t._pathsCache,o=i.length;let s,r,a,n,l,h,d,f,c,p,y,m,w,E,T,g,O,u="";if(o)for(s=0,r=e.length;s<r;s++)if(h=(l=(a=e[s]).path).length,!l.some(e=>"symbol"==typeof e)){for(E=!1,n=a.object,!Array.isArray(n)||"insert"!==a.type&&"delete"!==a.type||isNaN(l[l.length-1])?1===h?u=l[0]:h&&(u=2===h?l[0]+"."+l[1]:l.join(".")):(u=l.slice(0,-1).join("."),E=!0),y=u.length,d=o,O=new Map;d;)if(y>(f=i[--d]).length?(m=f,w=u):(m=u,w=f),T=m===w&&!E,0===w.indexOf(m))for(p=(c=t[f]).length;p;){g=c[--p];let e=O.get(g);e||(e={},O.set(g,e)),e[f]=T}this.updateViews(O,a)}}updateViews(e,t){let i,o;e.forEach((e,s)=>{for(i=s[VIEW_PARAMS_KEY],o=i.length;o;){const r=i[--o];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let o;const s=ties.get(t.tieKey);s&&(o=getPath(s,t.path),e=!0),i.push(o)}),e&&(i.push([t]),callViewFunction(s,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),setViewProperty(s,r,i)}}})}}export class Ties{constructor(){ties=this}get(e){const t="string"==typeof e?e:e?e[SCOPE_ROOT_KEY]:void 0,i=ties[t];return i?i.model:null}create(e,t){if(ties[e])throw new Error(`tie '${e}' already exists`);if(null===t)throw new Error("initial model, when provided, MUST NOT be null");this.validateTieKey(e);let i=e;"string"!=typeof i&&(i=getRandomKey(16),e[SCOPE_ROOT_KEY]=i);const o=obtainTieViews(i),s=new Tie(i,t,o);return ties[i]=s,s.processDataChanges([{path:[]}]),s.model}update(e,t){if(t&&"object"==typeof t){const i="string"==typeof e?e:e?e[SCOPE_ROOT_KEY]:void 0,o=ties[i];if(o)return o.model!==t&&(o.model=t,o.processDataChanges([{path:[]}])),o.model;console.error(`no tie matching ${e}`)}}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e[SCOPE_ROOT_KEY]:Object.keys(ties).find(t=>ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);ties[t]&&(delete ties[t],deleteTieViews(t))}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};