import{SCOPE_ROOT_KEY,VIEW_PARAMS_KEY,ensureObservable,getPath,setViewProperty,callViewFunction,getRandomKey}from"./utils.min.js";import{obtainTieViews,deleteTieViews}from"./views.min.js";const tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["scope"];let ties;class Tie{constructor(e,t,i){this.key=e,this.model=ensureObservable(t),this.views=i,this.ownModel=this.model!==t,this.model.observe(e=>this.processDataChanges(e))}processDataChanges(e){const t=this.views,i=t._pathsCache,s=i.length;let o,r,n,a,l,h,d,c,f,w,p,m,y,E,T,g,v="";if(s)for(o=0,r=e.length;o<r;o++){if(y=!1,a=(n=e[o]).object,l=n.path,!Array.isArray(a)||"insert"!==n.type&&"delete"!==n.type||isNaN(l[l.length-1])){const e=l.length;1===e?v=l[0]:e&&(v=2===e?l[0]+"."+l[1]:l.join("."))}else v=l.slice(0,-1).join("."),y=!0;for(w=v.length,h=s,g=new Map;h;)if(w>(d=i[--h]).length?(p=d,m=v):(p=v,m=d),E=p===m&&!y,0===m.indexOf(p))for(f=(c=t[d]).length;f;){T=c[--f];let e=g.get(T);e||(e={},g.set(T,e)),e[d]=E}this.updateViews(g,n)}}updateViews(e,t){let i,s;e.forEach((e,o)=>{for(i=o[VIEW_PARAMS_KEY],s=i.length;s;){const r=i[--s];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let s;const o=ties.get(t.tieKey);o&&(s=getPath(o,t.path),e=!0),i.push(s)}),e&&(i.push([t]),callViewFunction(o,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this.model,r.path))&&(i=""),setViewProperty(o,r,i)}}})}}export class Ties{constructor(){ties=this}get(e){const t="string"==typeof e?e:e?e[SCOPE_ROOT_KEY]:void 0,i=ties[t];return i?i.model:null}create(e,t){if(ties[e])throw new Error(`tie '${e}' already exists`);this.validateTieKey(e);let i=e;if("string"!=typeof i&&(i=getRandomKey(16),e[SCOPE_ROOT_KEY]=i),null===t)throw new Error("initial model, when provided, MUST NOT be null");const s=obtainTieViews(i),o=new Tie(i,t,s);return ties[i]=o,o.processDataChanges([{path:[]}]),o.model}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e[SCOPE_ROOT_KEY]:Object.keys(ties).find(t=>ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);const i=ties[t];i&&(delete ties[t],deleteTieViews(t),i.model&&i.ownModel&&i.model.revoke())}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};