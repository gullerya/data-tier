const e="insert",t="update",o="delete",r="reverse",n="shuffle",s=Symbol("system-observer-key"),p=["path","pathsFrom"],l=function(e){const t={};e.path&&"string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path,e.pathsFrom&&(e.path?console.error('"pathsFrom" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>p.indexOf(e)<0);return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t},a=function(){const e=this[s],t=u(e).observers;let o=t.length;if(o){let r=arguments.length;if(r)for(;r--;){let e=o;for(;e--;)t[e][0]===arguments[r]&&(t.splice(e,1),o--)}else for(;o--;)t[o][1].context===e&&t.splice(o,1)}},c={[s]:{writable:!0},revoke:{value:function(){this[s].revoke()}},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[s],r=o.observers;if(r.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let n;(n=t?l(t):{}).context=o,r.push([e,n])}}},unobserve:{value:a}},h={[s]:{writable:!0},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[s],r=u(o),n=r.path.join("."),p=r.observers;if(p.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let r;(r=t?l(t):{}).path?r.path=n+"."+r.path:r.pathsFrom=n+"."+(r.pathsFrom?r.pathsFrom:""),r.context=o,p.push([e,r])}}},unobserve:{value:a}},i=function(e,t,o){let r,n=e.length;const p=Object.defineProperties(new Array(n),t);for(p[s]=o;n--;)r=e[n],p[n]=r&&"object"==typeof r?y(r,n,o):r;return p},f=function(e,t,o){const r=Object.keys(e),n=Object.defineProperties({},t);n[s]=o;let p,l,a=r.length;for(;a--;)l=e[p=r[a]],n[p]=l&&"object"==typeof l?y(l,p,o):l;return n},b=function(e,t){let o,r,n,s,p,l,a=e.length;for(;a--;)try{r=(o=e[a])[0],n=o[1],s=t,n.path?(p=n.path,s=t.filter(e=>e.path.join(".")===p)):n.pathsFrom&&(l=n.pathsFrom,s=t.filter(e=>e.path.join(".").startsWith(l))),s.length&&r(s)}catch(e){console.error(`failed to deliver changes to listener ${r}`,e)}},u=function(e){const t=[];let o=0,r=0;for(;e.parent;)t[o++]=e.ownKey,e=e.parent;const n=new Array(o);for(;o--;)n[r++]=t[o];return{observers:e.observers,path:n}},y=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new g({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new j({target:e,ownKey:t,parent:o}).proxy:e};class v{constructor(e,t){const o=e.target,r=e.parent,n=e.ownKey;let s;r&&void 0!==n?(this.parent=r,this.ownKey=n,s=h):(this.isRevoked=!1,this.observers=[],s=c);const p=t(o,s,this);this.revokable=Proxy.revocable(p,this),this.proxy=this.revokable.proxy,this.target=p}set(o,r,n){let p,l=o[r];if(n===l)return!0;const a=y(n,r,this);if(o[r]=a,l&&"object"==typeof l){const e=l[s];e&&(l=e.revoke())}const c=u(this);return c.observers.length&&(c.path.push(r),p=void 0===l?[{type:e,path:c.path,value:a,object:this.proxy}]:[{type:t,path:c.path,value:a,oldValue:l,object:this.proxy}],b(c.observers,p)),!0}deleteProperty(e,t){let r,n=e[t];if(delete e[t],n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=u(this);return p.observers.length&&(p.path.push(t),r=[{type:o,path:p.path,oldValue:n,object:this.proxy}],b(p.observers,r)),!0}}class g extends v{constructor(e){super(e,i)}revoke(){this.revokable.revoke();const e=this.target;let t,o,r=e.length;for(;r--;)(t=e[r])&&"object"==typeof t&&(o=t[s])&&(e[r]=o.revoke());return e}get(p,l){const a={pop:function(e,t){const r=e.length-1;let n=e.pop();if(n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=u(t);return p.observers.length&&(p.path.push(r),b(p.observers,[{type:o,path:p.path,oldValue:n,object:t.proxy}])),n},push:function(t,o){let r,n,s,p,l=arguments.length-2;const a=new Array(l),c=t.length;for(r=0;r<l;r++)n=arguments[r+2],a[r]=y(n,c+r,o);const h=Reflect.apply(t.push,t,a),i=u(o);if(i.observers.length){for(s=[],r=c,l=t.length;r<l;r++)(p=i.path.slice(0)).push(r),s[r-c]={type:e,path:p,value:t[r],object:o.proxy};b(i.observers,s)}return h},shift:function(e,t){let r,n,p,l,a;for((r=e.shift())&&"object"==typeof r&&(a=r[s])&&(r=a.revoke()),n=0,p=e.length;n<p;n++)(l=e[n])&&"object"==typeof l&&(a=l[s])&&(a.ownKey=n);const c=u(t);return c.observers.length&&(c.path.push(0),b(c.observers,[{type:o,path:c.path,oldValue:r,object:t.proxy}])),r},unshift:function(t,o){const r=Array.from(arguments);let n;r.splice(0,2),r.forEach((e,t)=>{r[t]=y(e,t,o)});const p=Reflect.apply(t.unshift,t,r);for(let e,o=0,r=t.length;o<r;o++)if((e=t[o])&&"object"==typeof e){const t=e[s];t&&(t.ownKey=o)}const l=u(o);if(l.observers.length){const s=r.length;let p;n=new Array(s);for(let r=0;r<s;r++)(p=l.path.slice(0)).push(r),n[r]={type:e,path:p,value:t[r],object:o.proxy};b(l.observers,n)}return p},reverse:function(e,t){let o,n,p,l;for(e.reverse(),o=0,n=e.length;o<n;o++)if((p=e[o])&&"object"==typeof p){const e=p[s];e&&(e.ownKey=o)}const a=u(t);return a.observers.length&&(l=[{type:r,path:a.path,object:t.proxy}],b(a.observers,l)),t.proxy},sort:function(e,t,o){let r,p,l,a;for(e.sort(o),r=0,p=e.length;r<p;r++)if((l=e[r])&&"object"==typeof l){const e=l[s];e&&(e.ownKey=r)}const c=u(t);return c.observers.length&&(a=[{type:n,path:c.path,object:t.proxy}],b(c.observers,a)),t.proxy},fill:function(o,r){const n=u(r),p=[],l=o.length,a=Array.from(arguments);a.splice(0,2);const c=a.length,h=c<2?0:a[1]<0?l+a[1]:a[1],i=c<3?l:a[2]<0?l+a[2]:a[2],f=o.slice(0);let v,g;Reflect.apply(o.fill,o,a);for(let l,a,c=h;c<i;c++)l=o[c],o[c]=y(l,c,r),f.hasOwnProperty(c)?((a=f[c])&&"object"==typeof a&&(v=a[s])&&(a=v.revoke()),(g=n.path.slice(0)).push(c),p.push({type:t,path:g,value:o[c],oldValue:a,object:r.proxy})):((g=n.path.slice(0)).push(c),p.push({type:e,path:g,value:o[c],object:r.proxy}));return n.observers.length&&b(n.observers,p),r.proxy},splice:function(r,n){const p=u(n),l=[],a=Array.from(arguments),c=r.length;a.splice(0,2);const h=a.length;for(let e,t=2;t<h;t++)e=a[t],a[t]=y(e,t,n);const i=0===h?0:a[0]<0?c+a[0]:a[0],f=h<2?c-i:a[1],v=Math.max(h-2,0),g=Reflect.apply(r.splice,r,a),j=r.length;let w,d,x,m;for(let e,t=0;t<j;t++)(e=r[t])&&"object"==typeof e&&(w=e[s])&&(w.ownKey=t);for(d=0,x=g.length;d<x;d++)(m=g[d])&&"object"==typeof m&&(w=m[s])&&(g[d]=w.revoke());if(p.observers.length){let s,a;for(s=0;s<f;s++)(a=p.path.slice(0)).push(i+s),s<v?l.push({type:t,path:a,value:r[i+s],oldValue:g[s],object:n.proxy}):l.push({type:o,path:a,oldValue:g[s],object:n.proxy});for(;s<v;s++)(a=p.path.slice(0)).push(i+s),l.push({type:e,path:a,value:r[i+s],object:n.proxy});b(p.observers,l)}return g}};return a.hasOwnProperty(l)?a[l].bind(void 0,p,this):p[l]}}class j extends v{constructor(e){super(e,f)}revoke(){this.revokable.revoke();const e=this.target,t=Object.keys(e);let o,r,n,p=t.length;for(;p--;)(r=e[o=t[p]])&&"object"==typeof r&&(n=r[s])&&(e[o]=n.revoke());return e}}class w{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[s])return e;if(Array.isArray(e))return new g({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new j({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[s])}}Object.freeze(w);export{w as Observable};