const e="insert",t="update",r="delete",o="reverse",n="shuffle",s=Symbol("system-observer-key"),p=["path","pathsFrom"],a={revoke:{value:function(){this[s].revoke()}},observe:{value:function(e,t){const r=this[s].observers;if("function"!=typeof e)throw new Error("observer parameter MUST be a function");if(t){if("path"in t&&("string"!=typeof t.path||!t.path))throw new Error('"path" option, if/when provided, MUST be a non-empty string');if("pathsFrom"in t&&t.path)throw new Error('"pathsFrom" option MAY NOT be specified together with "path" option');if("pathsFrom"in t&&("string"!=typeof t.pathsFrom||!t.pathsFrom))throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');const e=Object.keys(t).find(e=>!p.includes(e));if(e)throw new Error('"'+e+'" is not a one of the valid options ('+p.join(", ")+")")}r.has(e)?console.info("observer may be bound to an observable only once"):r.set(e,Object.assign({},t))}},unobserve:{value:function(){const e=this[s].observers;let t;if(e.size)if(t=arguments.length)for(;t;)e.delete(arguments[--t]);else e.clear()}}},i=function(e,t){let r,o=e.length;const n=new Array(o);for(n[s]=t;o;)(r=e[--o])&&"object"==typeof r&&f(r)?n[o]=Array.isArray(r)?new u({target:r,ownKey:o,parent:t}).proxy:new v({target:r,ownKey:o,parent:t}).proxy:n[o]=r;return n},c=function(e,t){const r=Object.keys(e),o={[s]:t};let n,p,a=r.length;for(;a;)(p=e[n=r[--a]])&&"object"==typeof p&&f(p)?o[n]=Array.isArray(p)?new u({target:p,ownKey:n,parent:t}).proxy:new v({target:p,ownKey:n,parent:t}).proxy:o[n]=p;return o},h=function(e,t){let r,o,n,s,p;for(r of e.keys())try{o=e.get(r),n=t,o.path?(s=o.path,n=t.filter(e=>e.path.join(".")===s)):o.pathsFrom&&(p=o.pathsFrom,n=t.filter(e=>e.path.join(".").startsWith(p))),n.length&&r(n)}catch(e){console.error("failed to deliver changes to listener "+r,e)}},l=function(e){const t=[];let r=0,o=0;for(;e.parent;)t[r++]=e.ownKey,e=e.parent;const n=new Array(r);for(;r;)n[o++]=t[--r];return{observers:e.observers,path:n}},y=[Date,Blob,Number,String,Boolean,Error,Function,Promise,RegExp],f=function(e){return!y.some(t=>e instanceof t)};class b{constructor(e,t){const r=t(e.target,this);null===e.parent?(this.isRevoked=!1,Object.defineProperty(this,"observers",{value:new Map}),Object.defineProperties(r,a)):(this.parent=e.parent,this.ownKey=e.ownKey),this.revokable=Proxy.revocable(r,this),this.proxy=this.revokable.proxy,this.target=r}set(r,o,n){let p,a,i=r[o];if(n===i)return!0;if(p=n&&"object"==typeof n&&f(n)?Array.isArray(n)?new u({target:n,ownKey:o,parent:this}).proxy:new v({target:n,ownKey:o,parent:this}).proxy:n,r[o]=p,i&&"object"==typeof i){const e=i[s];e&&(i=e.revoke())}const c=l(this);return c.observers.size&&(c.path.push(o),a=void 0===i?[{type:e,path:c.path,value:p,object:this.proxy}]:[{type:t,path:c.path,value:p,oldValue:i,object:this.proxy}],h(c.observers,a)),!0}deleteProperty(e,t){let o,n=e[t];if(delete e[t],n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=l(this);return p.observers.size&&(p.path.push(t),o=[{type:r,path:p.path,oldValue:n,object:this.proxy}],h(p.observers,o)),!0}}class u extends b{constructor(e){super(e,i)}revoke(){this.revokable.revoke();const e=this.target;let t,r,o=e.length;for(;o;)(t=e[--o])&&"object"==typeof t&&(r=t[s])&&(e[o]=r.revoke());return e}get(p,a){const i={pop:function(e,t){const o=e.length-1;let n=e.pop();if(n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=l(t);return p.observers.size&&(p.path.push(o),h(p.observers,[{type:r,path:p.path,oldValue:n,object:t.proxy}])),n},push:function(t,r){let o,n,s,p,a=arguments.length-2;const i=new Array(a),c=t.length;for(o=0;o<a;o++)(n=arguments[o+2])&&"object"==typeof n&&f(n)&&(n=Array.isArray(n)?new u({target:n,ownKey:c+o,parent:r}).proxy:new v({target:n,ownKey:c+o,parent:r}).proxy),i[o]=n;const y=Reflect.apply(t.push,t,i),b=l(r);if(b.observers.size){for(s=[],o=c,a=t.length;o<a;o++)(p=b.path.slice(0)).push(o),s[o-c]={type:e,path:p,value:t[o],object:r.proxy};h(b.observers,s)}return y},shift:function(e,t){let o,n,p,a,i,c;for((o=e.shift())&&"object"==typeof o&&(c=o[s])&&(o=c.revoke()),n=0,p=e.length;n<p;n++)(a=e[n])&&"object"==typeof a&&(c=a[s])&&(c.ownKey=n);const y=l(t);return y.observers.size&&(y.path.push(0),i=[{type:r,path:y.path,oldValue:o,object:t.proxy}],h(y.observers,i)),o},unshift:function(t,r){const o=Array.from(arguments);let n;o.splice(0,2),o.forEach((e,t)=>{e&&"object"==typeof e&&f(e)&&(o[t]=Array.isArray(e)?new u({target:e,ownKey:t,parent:r}).proxy:new v({target:e,ownKey:t,parent:r}).proxy)});const p=Reflect.apply(t.unshift,t,o);for(let e,r=0,o=t.length;r<o;r++)if((e=t[r])&&"object"==typeof e){const t=e[s];t&&(t.ownKey=r)}const a=l(r);if(a.observers.size){const s=o.length;let p;n=new Array(s);for(let o=0;o<s;o++)(p=a.path.slice(0)).push(o),n[o]={type:e,path:p,value:t[o],object:r.proxy};h(a.observers,n)}return p},reverse:function(e,t){let r,n,p,a;for(e.reverse(),r=0,n=e.length;r<n;r++)if((p=e[r])&&"object"==typeof p){const e=p[s];e&&(e.ownKey=r)}const i=l(t);return i.observers.size&&(a=[{type:o,path:i.path,object:t.proxy}],h(i.observers,a)),t.proxy},sort:function(e,t,r){let o,p,a,i;for(e.sort(r),o=0,p=e.length;o<p;o++)if((a=e[o])&&"object"==typeof a){const e=a[s];e&&(e.ownKey=o)}const c=l(t);return c.observers.size&&(i=[{type:n,path:c.path,object:t.proxy}],h(c.observers,i)),t.proxy},fill:function(r,o){const n=l(o),p=[],a=r.length,i=Array.from(arguments);i.splice(0,2);const c=i.length,y=c<2?0:i[1]<0?a+i[1]:i[1],b=c<3?a:i[2]<0?a+i[2]:i[2],w=r.slice(0);let g,j;Reflect.apply(r.fill,r,i);for(let a,i,c=y;c<b;c++)(a=r[c])&&"object"==typeof a&&f(a)&&(r[c]=Array.isArray(a)?new u({target:a,ownKey:c,parent:o}).proxy:new v({target:a,ownKey:c,parent:o}).proxy),w.hasOwnProperty(c)?((i=w[c])&&"object"==typeof i&&(g=i[s])&&(i=g.revoke()),(j=n.path.slice(0)).push(c),p.push({type:t,path:j,value:r[c],oldValue:i,object:o.proxy})):((j=n.path.slice(0)).push(c),p.push({type:e,path:j,value:r[c],object:o.proxy}));return n.observers.size&&h(n.observers,p),o.proxy},splice:function(o,n){const p=l(n),a=[],i=Array.from(arguments),c=o.length;i.splice(0,2);const y=i.length;for(let e,t=2;t<y;t++)(e=i[t])&&"object"==typeof e&&f(e)&&(i[t]=Array.isArray(e)?new u({target:e,ownKey:t,parent:n}).proxy:new v({target:e,ownKey:t,parent:n}).proxy);const b=0===y?0:i[0]<0?c+i[0]:i[0],w=y<2?c-b:i[1],g=Math.max(y-2,0),j=Reflect.apply(o.splice,o,i),x=o.length;let d,k,A,m;for(let e,t=0;t<x;t++)(e=o[t])&&"object"==typeof e&&(d=e[s])&&(d.ownKey=t);for(k=0,A=j.length;k<A;k++)(m=j[k])&&"object"==typeof m&&(d=m[s])&&(j[k]=d.revoke());if(p.observers.size){let s,i;for(s=0;s<w;s++)(i=p.path.slice(0)).push(b+s),s<g?a.push({type:t,path:i,value:o[b+s],oldValue:j[s],object:n.proxy}):a.push({type:r,path:i,oldValue:j[s],object:n.proxy});for(;s<g;s++)(i=p.path.slice(0)).push(b+s),a.push({type:e,path:i,value:o[b+s],object:n.proxy});h(p.observers,a)}return j}};return i.hasOwnProperty(a)?i[a].bind(void 0,p,this):p[a]}}class v extends b{constructor(e){super(e,c)}revoke(){this.revokable.revoke();const e=this.target,t=Object.keys(e);let r,o,n,p=t.length;for(;p;)(o=e[r=t[--p]])&&"object"==typeof o&&(n=o[s])&&(e[r]=n.revoke());return e}}class w{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(!(!e||"object"!=typeof e||!f(e)||"observe"in e||"unobserve"in e||"revoke"in e)){return(Array.isArray(e)?new u({target:e,ownKey:null,parent:null}):new v({target:e,ownKey:null,parent:null})).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(!f(e))throw new Error(e+" found to be one of non-observable object types: "+y)}static isObservable(e){return!!(e&&e[s]&&e.observe)}}Object.freeze(w);export{w as Observable};