const e="insert",t="update",r="delete",o="reverse",n="shuffle",s=Symbol("system-observer-key"),p={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0},a=["path","pathsFrom"],i={revoke:{value:function(){this[s].revoke()}},observe:{value:function(e,t){let r=this[s].observers;if("function"!=typeof e)throw new Error("observer parameter MUST be a function");if(t){if("path"in t&&("string"!=typeof t.path||!t.path))throw new Error('"path" option, if/when provided, MUST be a non-empty string');if("pathsFrom"in t&&t.path)throw new Error('"pathsFrom" option MAY NOT be specified together with "path" option');if("pathsFrom"in t&&("string"!=typeof t.pathsFrom||!t.pathsFrom))throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');let e=Object.keys(t).find(e=>!a.includes(e));if(e)throw new Error('"'+e+'" is not a one of the valid options ('+a.join(", ")+")")}r.has(e)?console.info("observer may be bound to an observable only once"):r.set(e,Object.assign({},t))}},unobserve:{value:function(){let e,t=this[s].observers;if(t.size)if(e=arguments.length)for(;e--;)t.delete(arguments[e]);else t.clear()}}},l=function(e,t){let r,o=e.length,n=new Array(e.length);for(n[s]=t;o--;)(r=e[o])&&"object"==typeof r&&!p.hasOwnProperty(r.constructor.name)?n[o]=Array.isArray(r)?new b({target:r,ownKey:o,parent:t}).proxy:new u({target:r,ownKey:o,parent:t}).proxy:n[o]=r;return n},h=function(e,t){let r,o,n=Object.keys(e),a=n.length,i={[s]:t};for(;a--;)(o=e[r=n[a]])&&"object"==typeof o&&!p.hasOwnProperty(o.constructor.name)?i[r]=Array.isArray(o)?new b({target:o,ownKey:r,parent:t}).proxy:new u({target:o,ownKey:r,parent:t}).proxy:i[r]=o;return i},y=function(e,t){for(let r of e.keys())try{let o=t,n=e.get(r);if(n.path){let e=n.path;o=t.filter(t=>t.path.join(".")===e)}else if(n.pathsFrom){let e=n.pathsFrom;o=t.filter(t=>t.path.join(".").startsWith(e))}r(o)}catch(e){console.error("failed to deliver changes to listener "+r,e)}},c=function(e){let t,r=[],o=0,n=0;for(;e.parent;)r[o++]=e.ownKey,e=e.parent;for(t=new Array(o);o--;)t[n++]=r[o];return{observers:e.observers,path:t}};class f{constructor(e,t){let r=t(e.target,this);null===e.parent?(this.isRevoked=!1,Object.defineProperty(this,"observers",{value:new Map}),Object.defineProperties(r,i)):(this.parent=e.parent,this.ownKey=e.ownKey),this.revokable=Proxy.revocable(r,this),this.proxy=this.revokable.proxy,this.target=r}set(r,o,n){let a,i,l,h=r[o];if(a=n&&"object"==typeof n&&!p.hasOwnProperty(n.constructor.name)?Array.isArray(n)?new b({target:n,ownKey:o,parent:this}).proxy:new u({target:n,ownKey:o,parent:this}).proxy:n,r[o]=a,h&&"object"==typeof h){let e=h[s];e&&(h=e.revoke())}return(i=c(this)).observers.size&&(i.path.push(o),l=void 0===h?[{type:e,path:i.path,value:a,object:this.proxy}]:[{type:t,path:i.path,value:a,oldValue:h,object:this.proxy}],y(i.observers,l)),!0}deleteProperty(e,t){let o,n,p=e[t];if(delete e[t]){if(p&&"object"==typeof p){let e=p[s];e&&(p=e.revoke())}return(o=c(this)).observers.size&&(o.path.push(t),n=[{type:r,path:o.path,oldValue:p,object:this.proxy}],y(o.observers,n)),!0}return!1}}class b extends f{constructor(e){super(e,l)}revoke(){this.revokable.revoke();let e,t=this.target,r=t.length;for(;r--;)if((e=t[r])&&"object"==typeof e){let o=e[s];o&&(t[r]=o.revoke())}return t}get(a,i){const l={pop:function(e,t){let o,n;if(o=e.length-1,(n=e.pop())&&"object"==typeof n){let e=n[s];e&&(n=e.revoke())}let p=c(t);return p.observers.size&&(p.path.push(o),y(p.observers,[{type:r,path:p.path,oldValue:n,object:t.proxy}])),n},push:function(t,r){let o,n,s,a,i,l=arguments.length-2,h=new Array(l),f=c(r);for(i=t.length,o=0;o<l;o++)(n=arguments[o+2])&&"object"==typeof n&&!p.hasOwnProperty(n.constructor.name)&&(n=Array.isArray(n)?new b({target:n,ownKey:i+o,parent:r}).proxy:new u({target:n,ownKey:i+o,parent:r}).proxy),h[o]=n;if(s=Reflect.apply(t.push,t,h),f.observers.size){for(a=[],o=i,l=t.length;o<l;o++){let n=f.path.slice(0);n.push(o),a[o-i]={type:e,path:n,value:t[o],object:r.proxy}}y(f.observers,a)}return s},shift:function(e,t){let o,n,p,a,i,l;if((o=e.shift())&&"object"==typeof o){let e=o[s];e&&(o=e.revoke())}for(n=0,p=e.length;n<p;n++)if((a=e[n])&&"object"==typeof a){let e=a[s];e&&(e.ownKey=n)}return(i=c(t)).observers.size&&(i.path.push(0),l=[{type:r,path:i.path,oldValue:o,object:t.proxy}],y(i.observers,l)),o},unshift:function(t,r){let o,n,a,i;(o=Array.from(arguments)).splice(0,2),o.forEach((e,t)=>{e&&"object"==typeof e&&!p.hasOwnProperty(e.constructor.name)&&(o[t]=Array.isArray(e)?new b({target:e,ownKey:t,parent:r}).proxy:new u({target:e,ownKey:t,parent:r}).proxy)}),n=Reflect.apply(t.unshift,t,o);for(let e,r=0,o=t.length;r<o;r++)if((e=t[r])&&"object"==typeof e){let t=e[s];t&&(t.ownKey=r)}if((a=c(r)).observers.size){let n,s=o.length;i=new Array(s);for(let o=0;o<s;o++)(n=a.path.slice(0)).push(o),i[o]={type:e,path:n,value:t[o],object:r.proxy};y(a.observers,i)}return n},reverse:function(e,t){let r,n,p,a,i;for(e.reverse(),r=0,n=e.length;r<n;r++)if((p=e[r])&&"object"==typeof p){let e=p[s];e&&(e.ownKey=r)}return(a=c(t)).observers.size&&(i=[{type:o,path:a.path,object:t.proxy}],y(a.observers,i)),t.proxy},sort:function(e,t,r){let o,p,a,i,l;for(e.sort(r),o=0,p=e.length;o<p;o++)if((a=e[o])&&"object"==typeof a){let e=a[s];e&&(e.ownKey=o)}return(i=c(t)).observers.size&&(l=[{type:n,path:i.path,object:t.proxy}],y(i.observers,l)),t.proxy},fill:function(r,o){let n,a,i,l,h,f,v=c(o),w=[],g=r.length;(n=Array.from(arguments)).splice(0,2),i=(a=n.length)<2?0:n[1]<0?g+n[1]:n[1],l=a<3?g:n[2]<0?g+n[2]:n[2],h=r.slice(0),Reflect.apply(r.fill,r,n);for(let n,a,y=i;y<l;y++)if((n=r[y])&&"object"==typeof n&&!p.hasOwnProperty(n.constructor.name)&&(r[y]=Array.isArray(n)?new b({target:n,ownKey:y,parent:o}).proxy:new u({target:n,ownKey:y,parent:o}).proxy),h.hasOwnProperty(y)){if((a=h[y])&&"object"==typeof a){let e=a[s];e&&(a=e.revoke())}(f=v.path.slice(0)).push(y),w.push({type:t,path:f,value:r[y],oldValue:a,object:o.proxy})}else(f=v.path.slice(0)).push(y),w.push({type:e,path:f,value:r[y],object:o.proxy});return v.observers.size&&y(v.observers,w),o.proxy},splice:function(o,n){let a,i,l,h,f,v,w,g,j,x,d=c(n),m=[],k=o.length;(a=Array.from(arguments)).splice(0,2),w=a.length;for(let e,t=2;t<w;t++)(e=a[t])&&"object"==typeof e&&!p.hasOwnProperty(e.constructor.name)&&(a[t]=Array.isArray(e)?new b({target:e,ownKey:t,parent:n}).proxy:new u({target:e,ownKey:t,parent:n}).proxy);h=0===w?0:a[0]<0?k+a[0]:a[0],f=w<2?k-h:a[1],v=Math.max(w-2,0),i=Reflect.apply(o.splice,o,a),k=o.length;for(let e,t=0;t<k;t++)(e=o[t])&&"object"==typeof e&&(l=e[s])&&(l.ownKey=t);for(g=0,j=i.length;g<j;g++)(x=i[g])&&"object"==typeof x&&(l=x[s])&&(i[g]=l.revoke());if(d.observers.size){let s,p;for(s=0;s<f;s++)(p=d.path.slice(0)).push(h+s),s<v?m.push({type:t,path:p,value:o[h+s],oldValue:i[s],object:n.proxy}):m.push({type:r,path:p,oldValue:i[s],object:n.proxy});for(;s<v;s++)(p=d.path.slice(0)).push(h+s),m.push({type:e,path:p,value:o[h+s],object:n.proxy});y(d.observers,m)}return i}};return l.hasOwnProperty(i)?l[i].bind(void 0,a,this):a[i]}}class u extends f{constructor(e){super(e,h)}revoke(){this.revokable.revoke();let e,t,r=this.target,o=Object.keys(r),n=o.length;for(;n--;)if((t=r[e=o[n]])&&"object"==typeof t){let o=t[s];o&&(r[e]=o.revoke())}return r}}class v{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(!(!e||"object"!=typeof e||p.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return(Array.isArray(e)?new b({target:e,ownKey:null,parent:null}):new u({target:e,ownKey:null,parent:null})).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(p.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+p)}static isObservable(e){return!!(e&&e[s]&&e.observe)}}Object.freeze(v);export{v as Observable};