const e="insert",t="update",r="delete",o="reverse",n="shuffle",s=Symbol("system-observer-key"),p={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0},a=["path","pathsFrom"],c={revoke:{value:function(){this[s].revoke()}},observe:{value:function(e,t){const r=this[s].observers;if("function"!=typeof e)throw new Error("observer parameter MUST be a function");if(t){if("path"in t&&("string"!=typeof t.path||!t.path))throw new Error('"path" option, if/when provided, MUST be a non-empty string');if("pathsFrom"in t&&t.path)throw new Error('"pathsFrom" option MAY NOT be specified together with "path" option');if("pathsFrom"in t&&("string"!=typeof t.pathsFrom||!t.pathsFrom))throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');const e=Object.keys(t).find(e=>!a.includes(e));if(e)throw new Error('"'+e+'" is not a one of the valid options ('+a.join(", ")+")")}r.has(e)?console.info("observer may be bound to an observable only once"):r.set(e,Object.assign({},t))}},unobserve:{value:function(){const e=this[s].observers;let t;if(e.size)if(t=arguments.length)for(;t;)e.delete(arguments[--t]);else e.clear()}}},i=function(e,t){let r,o=e.length;const n=new Array(o);for(n[s]=t;o;)(r=e[--o])&&"object"==typeof r&&!Object.prototype.hasOwnProperty.call(p,r.constructor.name)?n[o]=Array.isArray(r)?new b({target:r,ownKey:o,parent:t}).proxy:new u({target:r,ownKey:o,parent:t}).proxy:n[o]=r;return n},h=function(e,t){const r=Object.keys(e),o={[s]:t};let n,a,c=r.length;for(;c;)(a=e[n=r[--c]])&&"object"==typeof a&&!p.hasOwnProperty(a.constructor.name)?o[n]=Array.isArray(a)?new b({target:a,ownKey:n,parent:t}).proxy:new u({target:a,ownKey:n,parent:t}).proxy:o[n]=a;return o},y=function(e,t){let r,o,n,s,p;for(r of e.keys())try{o=e.get(r),n=t,o.path?(s=o.path,n=t.filter(e=>e.path.join(".")===s)):o.pathsFrom&&(p=o.pathsFrom,n=t.filter(e=>e.path.join(".").startsWith(p))),n.length&&r(n)}catch(e){console.error("failed to deliver changes to listener "+r,e)}},l=function(e){const t=[];let r=0,o=0;for(;e.parent;)t[r++]=e.ownKey,e=e.parent;const n=new Array(r);for(;r;)n[o++]=t[--r];return{observers:e.observers,path:n}};class f{constructor(e,t){const r=t(e.target,this);null===e.parent?(this.isRevoked=!1,Object.defineProperty(this,"observers",{value:new Map}),Object.defineProperties(r,c)):(this.parent=e.parent,this.ownKey=e.ownKey),this.revokable=Proxy.revocable(r,this),this.proxy=this.revokable.proxy,this.target=r}set(r,o,n){let a,c,i=r[o];if(n===i)return!0;if(a=n&&"object"==typeof n&&!p.hasOwnProperty(n.constructor.name)?Array.isArray(n)?new b({target:n,ownKey:o,parent:this}).proxy:new u({target:n,ownKey:o,parent:this}).proxy:n,r[o]=a,i&&"object"==typeof i){const e=i[s];e&&(i=e.revoke())}const h=l(this);return h.observers.size&&(h.path.push(o),c=void 0===i?[{type:e,path:h.path,value:a,object:this.proxy}]:[{type:t,path:h.path,value:a,oldValue:i,object:this.proxy}],y(h.observers,c)),!0}deleteProperty(e,t){let o,n=e[t];if(delete e[t],n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=l(this);return p.observers.size&&(p.path.push(t),o=[{type:r,path:p.path,oldValue:n,object:this.proxy}],y(p.observers,o)),!0}}class b extends f{constructor(e){super(e,i)}revoke(){this.revokable.revoke();const e=this.target;let t,r,o=e.length;for(;o;)(t=e[--o])&&"object"==typeof t&&(r=t[s])&&(e[o]=r.revoke());return e}get(a,c){const i={pop:function(e,t){const o=e.length-1;let n=e.pop();if(n&&"object"==typeof n){const e=n[s];e&&(n=e.revoke())}const p=l(t);return p.observers.size&&(p.path.push(o),y(p.observers,[{type:r,path:p.path,oldValue:n,object:t.proxy}])),n},push:function(t,r){let o,n,s,a,c=arguments.length-2;const i=new Array(c),h=t.length;for(o=0;o<c;o++)(n=arguments[o+2])&&"object"==typeof n&&!p.hasOwnProperty(n.constructor.name)&&(n=Array.isArray(n)?new b({target:n,ownKey:h+o,parent:r}).proxy:new u({target:n,ownKey:h+o,parent:r}).proxy),i[o]=n;const f=Reflect.apply(t.push,t,i),v=l(r);if(v.observers.size){for(s=[],o=h,c=t.length;o<c;o++)(a=v.path.slice(0)).push(o),s[o-h]={type:e,path:a,value:t[o],object:r.proxy};y(v.observers,s)}return f},shift:function(e,t){let o,n,p,a,c,i;for((o=e.shift())&&"object"==typeof o&&(i=o[s])&&(o=i.revoke()),n=0,p=e.length;n<p;n++)(a=e[n])&&"object"==typeof a&&(i=a[s])&&(i.ownKey=n);const h=l(t);return h.observers.size&&(h.path.push(0),c=[{type:r,path:h.path,oldValue:o,object:t.proxy}],y(h.observers,c)),o},unshift:function(t,r){const o=Array.from(arguments);let n;o.splice(0,2),o.forEach((e,t)=>{e&&"object"==typeof e&&!p.hasOwnProperty(e.constructor.name)&&(o[t]=Array.isArray(e)?new b({target:e,ownKey:t,parent:r}).proxy:new u({target:e,ownKey:t,parent:r}).proxy)});const a=Reflect.apply(t.unshift,t,o);for(let e,r=0,o=t.length;r<o;r++)if((e=t[r])&&"object"==typeof e){const t=e[s];t&&(t.ownKey=r)}const c=l(r);if(c.observers.size){const s=o.length;let p;n=new Array(s);for(let o=0;o<s;o++)(p=c.path.slice(0)).push(o),n[o]={type:e,path:p,value:t[o],object:r.proxy};y(c.observers,n)}return a},reverse:function(e,t){let r,n,p,a;for(e.reverse(),r=0,n=e.length;r<n;r++)if((p=e[r])&&"object"==typeof p){const e=p[s];e&&(e.ownKey=r)}const c=l(t);return c.observers.size&&(a=[{type:o,path:c.path,object:t.proxy}],y(c.observers,a)),t.proxy},sort:function(e,t,r){let o,p,a,c;for(e.sort(r),o=0,p=e.length;o<p;o++)if((a=e[o])&&"object"==typeof a){const e=a[s];e&&(e.ownKey=o)}const i=l(t);return i.observers.size&&(c=[{type:n,path:i.path,object:t.proxy}],y(i.observers,c)),t.proxy},fill:function(r,o){const n=l(o),a=[],c=r.length,i=Array.from(arguments);i.splice(0,2);const h=i.length,f=h<2?0:i[1]<0?c+i[1]:i[1],v=h<3?c:i[2]<0?c+i[2]:i[2],w=r.slice(0);let g,j;Reflect.apply(r.fill,r,i);for(let c,i,h=f;h<v;h++)(c=r[h])&&"object"==typeof c&&!p.hasOwnProperty(c.constructor.name)&&(r[h]=Array.isArray(c)?new b({target:c,ownKey:h,parent:o}).proxy:new u({target:c,ownKey:h,parent:o}).proxy),w.hasOwnProperty(h)?((i=w[h])&&"object"==typeof i&&(g=i[s])&&(i=g.revoke()),(j=n.path.slice(0)).push(h),a.push({type:t,path:j,value:r[h],oldValue:i,object:o.proxy})):((j=n.path.slice(0)).push(h),a.push({type:e,path:j,value:r[h],object:o.proxy}));return n.observers.size&&y(n.observers,a),o.proxy},splice:function(o,n){const a=l(n),c=[],i=Array.from(arguments),h=o.length;i.splice(0,2);const f=i.length;for(let e,t=2;t<f;t++)(e=i[t])&&"object"==typeof e&&!p.hasOwnProperty(e.constructor.name)&&(i[t]=Array.isArray(e)?new b({target:e,ownKey:t,parent:n}).proxy:new u({target:e,ownKey:t,parent:n}).proxy);const v=0===f?0:i[0]<0?h+i[0]:i[0],w=f<2?h-v:i[1],g=Math.max(f-2,0),j=Reflect.apply(o.splice,o,i),x=o.length;let d,m,k,A;for(let e,t=0;t<x;t++)(e=o[t])&&"object"==typeof e&&(d=e[s])&&(d.ownKey=t);for(m=0,k=j.length;m<k;m++)(A=j[m])&&"object"==typeof A&&(d=A[s])&&(j[m]=d.revoke());if(a.observers.size){let s,p;for(s=0;s<w;s++)(p=a.path.slice(0)).push(v+s),s<g?c.push({type:t,path:p,value:o[v+s],oldValue:j[s],object:n.proxy}):c.push({type:r,path:p,oldValue:j[s],object:n.proxy});for(;s<g;s++)(p=a.path.slice(0)).push(v+s),c.push({type:e,path:p,value:o[v+s],object:n.proxy});y(a.observers,c)}return j}};return i.hasOwnProperty(c)?i[c].bind(void 0,a,this):a[c]}}class u extends f{constructor(e){super(e,h)}revoke(){this.revokable.revoke();const e=this.target,t=Object.keys(e);let r,o,n,p=t.length;for(;p;)(o=e[r=t[--p]])&&"object"==typeof o&&(n=o[s])&&(e[r]=n.revoke());return e}}class v{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(!(!e||"object"!=typeof e||p.hasOwnProperty(e.constructor.name)||"observe"in e||"unobserve"in e||"revoke"in e)){return(Array.isArray(e)?new b({target:e,ownKey:null,parent:null}):new u({target:e,ownKey:null,parent:null})).proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(p.hasOwnProperty(e.constructor.name))throw new Error(e+" found to be one of non-observable object types: "+p)}static isObservable(e){return!!(e&&e[s]&&e.observe)}}Object.freeze(v);export{v as Observable};